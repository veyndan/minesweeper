{"version":3,"sources":["Data.js"],"names":[],"mappings":"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","file":"Data-compiled.js","sourcesContent":["define( [\n\t\"../core\",\n\t\"../var/rnotwhite\",\n\t\"./var/acceptData\"\n], function( jQuery, rnotwhite, acceptData ) {\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tregister: function( owner, initial ) {\n\t\tvar value = initial || {};\n\n\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t// use plain assignment\n\t\tif ( owner.nodeType ) {\n\t\t\towner[ this.expando ] = value;\n\n\t\t// Otherwise secure it in a non-enumerable, non-writable property\n\t\t// configurability must be true to allow the property to be\n\t\t// deleted with the delete operator\n\t\t} else {\n\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t} );\n\t\t}\n\t\treturn owner[ this.expando ];\n\t},\n\tcache: function( owner ) {\n\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return an empty object.\n\t\tif ( !acceptData( owner ) ) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\t\t\towner[ this.expando ] && owner[ this.expando ][ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase( key ) );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.register( owner );\n\n\t\t} else {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <= 35-45+\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://code.google.com/p/chromium/issues/detail?id=378607\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\n\nreturn Data;\n} );\n"]}