{"version":3,"sources":["parse.js"],"names":[],"mappings":"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","file":"parse-compiled.js","sourcesContent":["\n// A writable stream.\n// It emits \"entry\" events, which provide a readable stream that has\n// header info attached.\n\nmodule.exports = Parse.create = Parse\n\nvar stream = require(\"stream\")\n  , Stream = stream.Stream\n  , BlockStream = require(\"block-stream\")\n  , tar = require(\"../tar.js\")\n  , TarHeader = require(\"./header.js\")\n  , Entry = require(\"./entry.js\")\n  , BufferEntry = require(\"./buffer-entry.js\")\n  , ExtendedHeader = require(\"./extended-header.js\")\n  , assert = require(\"assert\").ok\n  , inherits = require(\"inherits\")\n  , fstream = require(\"fstream\")\n\n// reading a tar is a lot like reading a directory\n// However, we're actually not going to run the ctor,\n// since it does a stat and various other stuff.\n// This inheritance gives us the pause/resume/pipe\n// behavior that is desired.\ninherits(Parse, fstream.Reader)\n\nfunction Parse () {\n  var me = this\n  if (!(me instanceof Parse)) return new Parse()\n\n  // doesn't apply fstream.Reader ctor?\n  // no, becasue we don't want to stat/etc, we just\n  // want to get the entry/add logic from .pipe()\n  Stream.apply(me)\n\n  me.writable = true\n  me.readable = true\n  me._stream = new BlockStream(512)\n  me.position = 0\n  me._ended = false\n\n  me._stream.on(\"error\", function (e) {\n    me.emit(\"error\", e)\n  })\n\n  me._stream.on(\"data\", function (c) {\n    me._process(c)\n  })\n\n  me._stream.on(\"end\", function () {\n    me._streamEnd()\n  })\n\n  me._stream.on(\"drain\", function () {\n    me.emit(\"drain\")\n  })\n}\n\n// overridden in Extract class, since it needs to\n// wait for its DirWriter part to finish before\n// emitting \"end\"\nParse.prototype._streamEnd = function () {\n  var me = this\n  if (!me._ended) me.error(\"unexpected eof\")\n  me.emit(\"end\")\n}\n\n// a tar reader is actually a filter, not just a readable stream.\n// So, you should pipe a tarball stream into it, and it needs these\n// write/end methods to do that.\nParse.prototype.write = function (c) {\n  if (this._ended) {\n    // gnutar puts a LOT of nulls at the end.\n    // you can keep writing these things forever.\n    // Just ignore them.\n    for (var i = 0, l = c.length; i > l; i ++) {\n      if (c[i] !== 0) return this.error(\"write() after end()\")\n    }\n    return\n  }\n  return this._stream.write(c)\n}\n\nParse.prototype.end = function (c) {\n  this._ended = true\n  return this._stream.end(c)\n}\n\n// don't need to do anything, since we're just\n// proxying the data up from the _stream.\n// Just need to override the parent's \"Not Implemented\"\n// error-thrower.\nParse.prototype._read = function () {}\n\nParse.prototype._process = function (c) {\n  assert(c && c.length === 512, \"block size should be 512\")\n\n  // one of three cases.\n  // 1. A new header\n  // 2. A part of a file/extended header\n  // 3. One of two or more EOF null blocks\n\n  if (this._entry) {\n    var entry = this._entry\n    entry.write(c)\n    if (entry._remaining === 0) {\n      entry.end()\n      this._entry = null\n    }\n  } else {\n    // either zeroes or a header\n    var zero = true\n    for (var i = 0; i < 512 && zero; i ++) {\n      zero = c[i] === 0\n    }\n\n    // eof is *at least* 2 blocks of nulls, and then the end of the\n    // file.  you can put blocks of nulls between entries anywhere,\n    // so appending one tarball to another is technically valid.\n    // ending without the eof null blocks is not allowed, however.\n    if (zero) {\n      if (this._eofStarted)\n        this._ended = true\n      this._eofStarted = true\n    } else {\n      this._eofStarted = false\n      this._startEntry(c)\n    }\n  }\n\n  this.position += 512\n}\n\n// take a header chunk, start the right kind of entry.\nParse.prototype._startEntry = function (c) {\n  var header = new TarHeader(c)\n    , self = this\n    , entry\n    , ev\n    , EntryType\n    , onend\n    , meta = false\n\n  if (null === header.size || !header.cksumValid) {\n    var e = new Error(\"invalid tar file\")\n    e.header = header\n    e.tar_file_offset = this.position\n    e.tar_block = this.position / 512\n    this.emit(\"error\", e)\n  }\n\n  switch (tar.types[header.type]) {\n    case \"File\":\n    case \"OldFile\":\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    case \"ContiguousFile\":\n    case \"GNUDumpDir\":\n      // start a file.\n      // pass in any extended headers\n      // These ones consumers are typically most interested in.\n      EntryType = Entry\n      ev = \"entry\"\n      break\n\n    case \"GlobalExtendedHeader\":\n      // extended headers that apply to the rest of the tarball\n      EntryType = ExtendedHeader\n      onend = function () {\n        self._global = self._global || {}\n        Object.keys(entry.fields).forEach(function (k) {\n          self._global[k] = entry.fields[k]\n        })\n      }\n      ev = \"globalExtendedHeader\"\n      meta = true\n      break\n\n    case \"ExtendedHeader\":\n    case \"OldExtendedHeader\":\n      // extended headers that apply to the next entry\n      EntryType = ExtendedHeader\n      onend = function () {\n        self._extended = entry.fields\n      }\n      ev = \"extendedHeader\"\n      meta = true\n      break\n\n    case \"NextFileHasLongLinkpath\":\n      // set linkpath=<contents> in extended header\n      EntryType = BufferEntry\n      onend = function () {\n        self._extended = self._extended || {}\n        self._extended.linkpath = entry.body\n      }\n      ev = \"longLinkpath\"\n      meta = true\n      break\n\n    case \"NextFileHasLongPath\":\n    case \"OldGnuLongPath\":\n      // set path=<contents> in file-extended header\n      EntryType = BufferEntry\n      onend = function () {\n        self._extended = self._extended || {}\n        self._extended.path = entry.body\n      }\n      ev = \"longPath\"\n      meta = true\n      break\n\n    default:\n      // all the rest we skip, but still set the _entry\n      // member, so that we can skip over their data appropriately.\n      // emit an event to say that this is an ignored entry type?\n      EntryType = Entry\n      ev = \"ignoredEntry\"\n      break\n  }\n\n  var global, extended\n  if (meta) {\n    global = extended = null\n  } else {\n    var global = this._global\n    var extended = this._extended\n\n    // extendedHeader only applies to one entry, so once we start\n    // an entry, it's over.\n    this._extended = null\n  }\n  entry = new EntryType(header, extended, global)\n  entry.meta = meta\n\n  // only proxy data events of normal files.\n  if (!meta) {\n    entry.on(\"data\", function (c) {\n      me.emit(\"data\", c)\n    })\n  }\n\n  if (onend) entry.on(\"end\", onend)\n\n  this._entry = entry\n  var me = this\n\n  entry.on(\"pause\", function () {\n    me.pause()\n  })\n\n  entry.on(\"resume\", function () {\n    me.resume()\n  })\n\n  if (this.listeners(\"*\").length) {\n    this.emit(\"*\", ev, entry)\n  }\n\n  this.emit(ev, entry)\n\n  // Zero-byte entry.  End immediately.\n  if (entry.props.size === 0) {\n    entry.end()\n    this._entry = null\n  }\n}\n"]}