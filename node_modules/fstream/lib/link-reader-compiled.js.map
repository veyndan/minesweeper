{"version":3,"sources":["link-reader.js"],"names":[],"mappings":";;;;;;AAMA,OAAO,OAAP,GAAiB,UAAjB;;AAEA,IAAI,KAAK,QAAQ,aAAR,CAAT;AAAA,IACI,UAAU,QAAQ,eAAR,CADd;AAAA,IAEI,WAAW,QAAQ,UAAR,CAFf;AAAA,IAGI,QAAQ,QAAQ,QAAR,CAHZ;AAAA,IAII,SAAS,QAAQ,aAAR,CAJb;;AAMA,SAAS,UAAT,EAAqB,MAArB;;AAEA,SAAS,UAAT,CAAqB,KAArB,EAA4B;AAC1B,MAAI,KAAK,IAAT;AACA,MAAI,EAAE,cAAc,UAAhB,CAAJ,EAAiC,MAAM,IAAI,KAAJ,CACrC,2CADqC,CAAN;;AAGjC,MAAI,EAAG,MAAM,IAAN,KAAe,MAAf,IAAyB,MAAM,IAAhC,IACC,MAAM,IAAN,KAAe,cAAf,IAAiC,MAAM,YAD1C,CAAJ,EAC8D;AAC5D,UAAM,IAAI,KAAJ,CAAU,mBAAkB,MAAM,IAAlC,CAAN;AACD;;AAED,SAAO,IAAP,CAAY,EAAZ,EAAgB,KAAhB;AACD;;;;;;AAMD,WAAW,SAAX,CAAqB,KAArB,GAA6B,UAAU,WAAV,EAAuB;AAClD,MAAI,KAAK,IAAT;AACA,KAAG,QAAH,CAAY,GAAG,KAAf,EAAsB,UAAU,EAAV,EAAc,QAAd,EAAwB;AAC5C,QAAI,EAAJ,EAAQ,OAAO,GAAG,KAAH,CAAS,EAAT,CAAP;AACR,OAAG,QAAH,GAAc,GAAG,KAAH,CAAS,QAAT,GAAoB,QAAlC;AACA,OAAG,IAAH,CAAQ,UAAR,EAAoB,QAApB;AACA,WAAO,SAAP,CAAiB,KAAjB,CAAuB,IAAvB,CAA4B,EAA5B,EAAgC,WAAhC;AACD,GALD;AAMD,CARD;;AAUA,WAAW,SAAX,CAAqB,KAArB,GAA6B,YAAY;AACvC,MAAI,KAAK,IAAT;AACA,MAAI,GAAG,OAAP,EAAgB;;;AAGhB,MAAI,CAAC,GAAG,MAAR,EAAgB;AACd,OAAG,IAAH,CAAQ,KAAR;AACA,OAAG,IAAH,CAAQ,OAAR;AACA,OAAG,MAAH,GAAY,IAAZ;AACD;AACF,CAVD","file":"link-reader-compiled.js","sourcesContent":["// Basically just a wrapper around an fs.readlink\n//\n// XXX: Enhance this to support the Link type, by keeping\n// a lookup table of {<dev+inode>:<path>}, so that hardlinks\n// can be preserved in tarballs.\n\nmodule.exports = LinkReader\n\nvar fs = require(\"graceful-fs\")\n  , fstream = require(\"../fstream.js\")\n  , inherits = require(\"inherits\")\n  , mkdir = require(\"mkdirp\")\n  , Reader = require(\"./reader.js\")\n\ninherits(LinkReader, Reader)\n\nfunction LinkReader (props) {\n  var me = this\n  if (!(me instanceof LinkReader)) throw new Error(\n    \"LinkReader must be called as constructor.\")\n\n  if (!((props.type === \"Link\" && props.Link) ||\n        (props.type === \"SymbolicLink\" && props.SymbolicLink))) {\n    throw new Error(\"Non-link type \"+ props.type)\n  }\n\n  Reader.call(me, props)\n}\n\n// When piping a LinkReader into a LinkWriter, we have to\n// already have the linkpath property set, so that has to\n// happen *before* the \"ready\" event, which means we need to\n// override the _stat method.\nLinkReader.prototype._stat = function (currentStat) {\n  var me = this\n  fs.readlink(me._path, function (er, linkpath) {\n    if (er) return me.error(er)\n    me.linkpath = me.props.linkpath = linkpath\n    me.emit(\"linkpath\", linkpath)\n    Reader.prototype._stat.call(me, currentStat)\n  })\n}\n\nLinkReader.prototype._read = function () {\n  var me = this\n  if (me._paused) return\n  // basically just a no-op, since we got all the info we need\n  // from the _stat method\n  if (!me._ended) {\n    me.emit(\"end\")\n    me.emit(\"close\")\n    me._ended = true\n  }\n}\n"]}