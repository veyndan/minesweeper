{"version":3,"sources":["dir-writer.js"],"names":[],"mappings":"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","file":"dir-writer-compiled.js","sourcesContent":["// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\n\nmodule.exports = DirWriter\n\nvar fs = require(\"graceful-fs\")\n  , fstream = require(\"../fstream.js\")\n  , Writer = require(\"./writer.js\")\n  , inherits = require(\"inherits\")\n  , mkdir = require(\"mkdirp\")\n  , path = require(\"path\")\n  , collect = require(\"./collect.js\")\n\ninherits(DirWriter, Writer)\n\nfunction DirWriter (props) {\n  var me = this\n  if (!(me instanceof DirWriter)) me.error(\n    \"DirWriter must be called as constructor.\", null, true)\n\n  // should already be established as a Directory type\n  if (props.type !== \"Directory\" || !props.Directory) {\n    me.error(\"Non-directory type \"+ props.type + \" \" +\n                    JSON.stringify(props), null, true)\n  }\n\n  Writer.call(this, props)\n}\n\nDirWriter.prototype._create = function () {\n  var me = this\n  mkdir(me._path, Writer.dirmode, function (er) {\n    if (er) return me.error(er)\n    // ready to start getting entries!\n    me.ready = true\n    me.emit(\"ready\")\n    me._process()\n  })\n}\n\n// a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\nDirWriter.prototype.write = function () {\n  return true\n}\n\nDirWriter.prototype.end = function () {\n  this._ended = true\n  this._process()\n}\n\nDirWriter.prototype.add = function (entry) {\n  var me = this\n\n  // console.error(\"\\tadd\", entry._path, \"->\", me._path)\n  collect(entry)\n  if (!me.ready || me._currentEntry) {\n    me._buffer.push(entry)\n    return false\n  }\n\n  // create a new writer, and pipe the incoming entry into it.\n  if (me._ended) {\n    return me.error(\"add after end\")\n  }\n\n  me._buffer.push(entry)\n  me._process()\n\n  return 0 === this._buffer.length\n}\n\nDirWriter.prototype._process = function () {\n  var me = this\n\n  // console.error(\"DW Process p=%j\", me._processing, me.basename)\n\n  if (me._processing) return\n\n  var entry = me._buffer.shift()\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    me.emit(\"drain\")\n    if (me._ended) me._finish()\n    return\n  }\n\n  me._processing = true\n  // console.error(\"DW Entry\", entry._path)\n\n  me.emit(\"entry\", entry)\n\n  // ok, add this entry\n  //\n  // don't allow recursive copying\n  var p = entry\n  do {\n    var pp = p._path || p.path\n    if (pp === me.root._path || pp === me._path ||\n        (pp && pp.indexOf(me._path) === 0)) {\n      // console.error(\"DW Exit (recursive)\", entry.basename, me._path)\n      me._processing = false\n      if (entry._collected) entry.pipe()\n      return me._process()\n    }\n  } while (p = p.parent)\n\n  // console.error(\"DW not recursive\")\n\n  // chop off the entry's root dir, replace with ours\n  var props = { parent: me\n              , root: me.root || me\n              , type: entry.type\n              , depth: me.depth + 1 }\n\n  var p = entry._path || entry.path || entry.props.path\n  if (entry.parent) {\n    p = p.substr(entry.parent._path.length + 1)\n  }\n  // get rid of any ../../ shenanigans\n  props.path = path.join(me.path, path.join(\"/\", p))\n\n  // if i have a filter, the child should inherit it.\n  props.filter = me.filter\n\n  // all the rest of the stuff, copy over from the source.\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k]\n    }\n  })\n\n  // not sure at this point what kind of writer this is.\n  var child = me._currentChild = new Writer(props)\n  child.on(\"ready\", function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child)\n    entry.resume()\n  })\n\n  // XXX Make this work in node.\n  // Long filenames should not break stuff.\n  child.on(\"error\", function (er) {\n    if (child._swallowErrors) {\n      me.warn(er)\n      child.emit(\"end\")\n      child.emit(\"close\")\n    } else {\n      me.emit(\"error\", er)\n    }\n  })\n\n  // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n  child.on(\"close\", onend)\n  var ended = false\n  function onend () {\n    if (ended) return\n    ended = true\n    // console.error(\"* DW Child end\", child.basename)\n    me._currentChild = null\n    me._processing = false\n    me._process()\n  }\n}\n"]}