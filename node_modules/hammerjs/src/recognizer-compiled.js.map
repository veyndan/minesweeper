{"version":3,"sources":["recognizer.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,IAAI,iBAAiB,CAArB;AACA,IAAI,cAAc,CAAlB;AACA,IAAI,gBAAgB,CAApB;AACA,IAAI,cAAc,CAAlB;AACA,IAAI,mBAAmB,WAAvB;AACA,IAAI,kBAAkB,EAAtB;AACA,IAAI,eAAe,EAAnB;;;;;;;;AAQA,SAAS,UAAT,CAAoB,OAApB,EAA6B;AACzB,SAAK,OAAL,GAAe,OAAO,EAAP,EAAW,KAAK,QAAhB,EAA0B,WAAW,EAArC,CAAf;;AAEA,SAAK,EAAL,GAAU,UAAV;;AAEA,SAAK,OAAL,GAAe,IAAf;;;AAGA,SAAK,OAAL,CAAa,MAAb,GAAsB,YAAY,KAAK,OAAL,CAAa,MAAzB,EAAiC,IAAjC,CAAtB;;AAEA,SAAK,KAAL,GAAa,cAAb;;AAEA,SAAK,YAAL,GAAoB,EAApB;AACA,SAAK,WAAL,GAAmB,EAAnB;AACH;;AAED,WAAW,SAAX,GAAuB;;;;;AAKnB,cAAU,EALS;;;;;;;AAYnB,SAAK,UAAS,OAAT,EAAkB;AACnB,eAAO,KAAK,OAAZ,EAAqB,OAArB;;;AAGA,aAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,WAAb,CAAyB,MAAzB,EAAhB;AACA,eAAO,IAAP;AACH,KAlBkB;;;;;;;AAyBnB,mBAAe,UAAS,eAAT,EAA0B;AACrC,YAAI,eAAe,eAAf,EAAgC,eAAhC,EAAiD,IAAjD,CAAJ,EAA4D;AACxD,mBAAO,IAAP;AACH;;AAED,YAAI,eAAe,KAAK,YAAxB;AACA,0BAAkB,6BAA6B,eAA7B,EAA8C,IAA9C,CAAlB;AACA,YAAI,CAAC,aAAa,gBAAgB,EAA7B,CAAL,EAAuC;AACnC,yBAAa,gBAAgB,EAA7B,IAAmC,eAAnC;AACA,4BAAgB,aAAhB,CAA8B,IAA9B;AACH;AACD,eAAO,IAAP;AACH,KArCkB;;;;;;;AA4CnB,uBAAmB,UAAS,eAAT,EAA0B;AACzC,YAAI,eAAe,eAAf,EAAgC,mBAAhC,EAAqD,IAArD,CAAJ,EAAgE;AAC5D,mBAAO,IAAP;AACH;;AAED,0BAAkB,6BAA6B,eAA7B,EAA8C,IAA9C,CAAlB;AACA,eAAO,KAAK,YAAL,CAAkB,gBAAgB,EAAlC,CAAP;AACA,eAAO,IAAP;AACH,KApDkB;;;;;;;AA2DnB,oBAAgB,UAAS,eAAT,EAA0B;AACtC,YAAI,eAAe,eAAf,EAAgC,gBAAhC,EAAkD,IAAlD,CAAJ,EAA6D;AACzD,mBAAO,IAAP;AACH;;AAED,YAAI,cAAc,KAAK,WAAvB;AACA,0BAAkB,6BAA6B,eAA7B,EAA8C,IAA9C,CAAlB;AACA,YAAI,QAAQ,WAAR,EAAqB,eAArB,MAA0C,CAAC,CAA/C,EAAkD;AAC9C,wBAAY,IAAZ,CAAiB,eAAjB;AACA,4BAAgB,cAAhB,CAA+B,IAA/B;AACH;AACD,eAAO,IAAP;AACH,KAvEkB;;;;;;;AA8EnB,wBAAoB,UAAS,eAAT,EAA0B;AAC1C,YAAI,eAAe,eAAf,EAAgC,oBAAhC,EAAsD,IAAtD,CAAJ,EAAiE;AAC7D,mBAAO,IAAP;AACH;;AAED,0BAAkB,6BAA6B,eAA7B,EAA8C,IAA9C,CAAlB;AACA,YAAI,QAAQ,QAAQ,KAAK,WAAb,EAA0B,eAA1B,CAAZ;AACA,YAAI,QAAQ,CAAC,CAAb,EAAgB;AACZ,iBAAK,WAAL,CAAiB,MAAjB,CAAwB,KAAxB,EAA+B,CAA/B;AACH;AACD,eAAO,IAAP;AACH,KAzFkB;;;;;;AA+FnB,wBAAoB,YAAW;AAC3B,eAAO,KAAK,WAAL,CAAiB,MAAjB,GAA0B,CAAjC;AACH,KAjGkB;;;;;;;AAwGnB,sBAAkB,UAAS,eAAT,EAA0B;AACxC,eAAO,CAAC,CAAC,KAAK,YAAL,CAAkB,gBAAgB,EAAlC,CAAT;AACH,KA1GkB;;;;;;;AAiHnB,UAAM,UAAS,KAAT,EAAgB;AAClB,YAAI,OAAO,IAAX;AACA,YAAI,QAAQ,KAAK,KAAjB;;AAEA,iBAAS,IAAT,CAAc,KAAd,EAAqB;AACjB,iBAAK,OAAL,CAAa,IAAb,CAAkB,KAAlB,EAAyB,KAAzB;AACH;;;AAGD,YAAI,QAAQ,WAAZ,EAAyB;AACrB,iBAAK,KAAK,OAAL,CAAa,KAAb,GAAqB,SAAS,KAAT,CAA1B;AACH;;AAED,aAAK,KAAK,OAAL,CAAa,KAAlB,E;;AAEA,YAAI,MAAM,eAAV,EAA2B;;AACvB,iBAAK,MAAM,eAAX;AACH;;;AAGD,YAAI,SAAS,WAAb,EAA0B;AACtB,iBAAK,KAAK,OAAL,CAAa,KAAb,GAAqB,SAAS,KAAT,CAA1B;AACH;AACJ,KAxIkB;;;;;;;;AAgJnB,aAAS,UAAS,KAAT,EAAgB;AACrB,YAAI,KAAK,OAAL,EAAJ,EAAoB;AAChB,mBAAO,KAAK,IAAL,CAAU,KAAV,CAAP;AACH;;AAED,aAAK,KAAL,GAAa,YAAb;AACH,KAtJkB;;;;;;AA4JnB,aAAS,YAAW;AAChB,YAAI,IAAI,CAAR;AACA,eAAO,IAAI,KAAK,WAAL,CAAiB,MAA5B,EAAoC;AAChC,gBAAI,EAAE,KAAK,WAAL,CAAiB,CAAjB,EAAoB,KAApB,IAA6B,eAAe,cAA5C,CAAF,CAAJ,EAAoE;AAChE,uBAAO,KAAP;AACH;AACD;AACH;AACD,eAAO,IAAP;AACH,KArKkB;;;;;;AA2KnB,eAAW,UAAS,SAAT,EAAoB;;;AAG3B,YAAI,iBAAiB,OAAO,EAAP,EAAW,SAAX,CAArB;;;AAGA,YAAI,CAAC,SAAS,KAAK,OAAL,CAAa,MAAtB,EAA8B,CAAC,IAAD,EAAO,cAAP,CAA9B,CAAL,EAA4D;AACxD,iBAAK,KAAL;AACA,iBAAK,KAAL,GAAa,YAAb;AACA;AACH;;;AAGD,YAAI,KAAK,KAAL,IAAc,mBAAmB,eAAnB,GAAqC,YAAnD,CAAJ,EAAsE;AAClE,iBAAK,KAAL,GAAa,cAAb;AACH;;AAED,aAAK,KAAL,GAAa,KAAK,OAAL,CAAa,cAAb,CAAb;;;;AAIA,YAAI,KAAK,KAAL,IAAc,cAAc,aAAd,GAA8B,WAA9B,GAA4C,eAA1D,CAAJ,EAAgF;AAC5E,iBAAK,OAAL,CAAa,cAAb;AACH;AACJ,KAnMkB;;;;;;;;;AA4MnB,aAAS,UAAS,SAAT,EAAoB,CAAG,CA5Mb,E;;;;;;;AAmNnB,oBAAgB,YAAW,CAAG,CAnNX;;;;;;;AA0NnB,WAAO,YAAW,CAAG;AA1NF,CAAvB;;;;;;;AAkOA,SAAS,QAAT,CAAkB,KAAlB,EAAyB;AACrB,QAAI,QAAQ,eAAZ,EAA6B;AACzB,eAAO,QAAP;AACH,KAFD,MAEO,IAAI,QAAQ,WAAZ,EAAyB;AAC5B,eAAO,KAAP;AACH,KAFM,MAEA,IAAI,QAAQ,aAAZ,EAA2B;AAC9B,eAAO,MAAP;AACH,KAFM,MAEA,IAAI,QAAQ,WAAZ,EAAyB;AAC5B,eAAO,OAAP;AACH;AACD,WAAO,EAAP;AACH;;;;;;;AAOD,SAAS,YAAT,CAAsB,SAAtB,EAAiC;AAC7B,QAAI,aAAa,cAAjB,EAAiC;AAC7B,eAAO,MAAP;AACH,KAFD,MAEO,IAAI,aAAa,YAAjB,EAA+B;AAClC,eAAO,IAAP;AACH,KAFM,MAEA,IAAI,aAAa,cAAjB,EAAiC;AACpC,eAAO,MAAP;AACH,KAFM,MAEA,IAAI,aAAa,eAAjB,EAAkC;AACrC,eAAO,OAAP;AACH;AACD,WAAO,EAAP;AACH;;;;;;;;AAQD,SAAS,4BAAT,CAAsC,eAAtC,EAAuD,UAAvD,EAAmE;AAC/D,QAAI,UAAU,WAAW,OAAzB;AACA,QAAI,OAAJ,EAAa;AACT,eAAO,QAAQ,GAAR,CAAY,eAAZ,CAAP;AACH;AACD,WAAO,eAAP;AACH","file":"recognizer-compiled.js","sourcesContent":["/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n"]}