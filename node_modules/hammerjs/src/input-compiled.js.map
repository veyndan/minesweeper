{"version":3,"sources":["input.js"],"names":[],"mappings":"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","file":"input-compiled.js","sourcesContent":["var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n"]}