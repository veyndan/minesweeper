{"version":3,"sources":["tap.js"],"names":[],"mappings":";;;;;;;;;;AAUA,SAAS,aAAT,GAAyB;AACrB,eAAW,KAAX,CAAiB,IAAjB,EAAuB,SAAvB;;;;AAIA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,OAAL,GAAe,KAAf;;AAEA,SAAK,MAAL,GAAc,IAAd;AACA,SAAK,MAAL,GAAc,IAAd;AACA,SAAK,KAAL,GAAa,CAAb;AACH;;AAED,QAAQ,aAAR,EAAuB,UAAvB,EAAmC;;;;;AAK/B,cAAU;AACN,eAAO,KADD;AAEN,kBAAU,CAFJ;AAGN,cAAM,CAHA;AAIN,kBAAU,GAJJ,E;AAKN,cAAM,GALA,E;AAMN,mBAAW,CANL,E;AAON,sBAAc,E;AAPR,KALqB;;AAe/B,oBAAgB,YAAW;AACvB,eAAO,CAAC,yBAAD,CAAP;AACH,KAjB8B;;AAmB/B,aAAS,UAAS,KAAT,EAAgB;AACrB,YAAI,UAAU,KAAK,OAAnB;;AAEA,YAAI,gBAAgB,MAAM,QAAN,CAAe,MAAf,KAA0B,QAAQ,QAAtD;AACA,YAAI,gBAAgB,MAAM,QAAN,GAAiB,QAAQ,SAA7C;AACA,YAAI,iBAAiB,MAAM,SAAN,GAAkB,QAAQ,IAA/C;;AAEA,aAAK,KAAL;;AAEA,YAAK,MAAM,SAAN,GAAkB,WAAnB,IAAoC,KAAK,KAAL,KAAe,CAAvD,EAA2D;AACvD,mBAAO,KAAK,WAAL,EAAP;AACH;;;;AAID,YAAI,iBAAiB,cAAjB,IAAmC,aAAvC,EAAsD;AAClD,gBAAI,MAAM,SAAN,IAAmB,SAAvB,EAAkC;AAC9B,uBAAO,KAAK,WAAL,EAAP;AACH;;AAED,gBAAI,gBAAgB,KAAK,KAAL,GAAc,MAAM,SAAN,GAAkB,KAAK,KAAvB,GAA+B,QAAQ,QAArD,GAAiE,IAArF;AACA,gBAAI,gBAAgB,CAAC,KAAK,OAAN,IAAiB,YAAY,KAAK,OAAjB,EAA0B,MAAM,MAAhC,IAA0C,QAAQ,YAAvF;;AAEA,iBAAK,KAAL,GAAa,MAAM,SAAnB;AACA,iBAAK,OAAL,GAAe,MAAM,MAArB;;AAEA,gBAAI,CAAC,aAAD,IAAkB,CAAC,aAAvB,EAAsC;AAClC,qBAAK,KAAL,GAAa,CAAb;AACH,aAFD,MAEO;AACH,qBAAK,KAAL,IAAc,CAAd;AACH;;AAED,iBAAK,MAAL,GAAc,KAAd;;;;AAIA,gBAAI,WAAW,KAAK,KAAL,GAAa,QAAQ,IAApC;AACA,gBAAI,aAAa,CAAjB,EAAoB;;;AAGhB,oBAAI,CAAC,KAAK,kBAAL,EAAL,EAAgC;AAC5B,2BAAO,gBAAP;AACH,iBAFD,MAEO;AACH,yBAAK,MAAL,GAAc,kBAAkB,YAAW;AACvC,6BAAK,KAAL,GAAa,gBAAb;AACA,6BAAK,OAAL;AACH,qBAHa,EAGX,QAAQ,QAHG,EAGO,IAHP,CAAd;AAIA,2BAAO,WAAP;AACH;AACJ;AACJ;AACD,eAAO,YAAP;AACH,KAvE8B;;AAyE/B,iBAAa,YAAW;AACpB,aAAK,MAAL,GAAc,kBAAkB,YAAW;AACvC,iBAAK,KAAL,GAAa,YAAb;AACH,SAFa,EAEX,KAAK,OAAL,CAAa,QAFF,EAEY,IAFZ,CAAd;AAGA,eAAO,YAAP;AACH,KA9E8B;;AAgF/B,WAAO,YAAW;AACd,qBAAa,KAAK,MAAlB;AACH,KAlF8B;;AAoF/B,UAAM,YAAW;AACb,YAAI,KAAK,KAAL,IAAc,gBAAlB,EAAoC;AAChC,iBAAK,MAAL,CAAY,QAAZ,GAAuB,KAAK,KAA5B;AACA,iBAAK,OAAL,CAAa,IAAb,CAAkB,KAAK,OAAL,CAAa,KAA/B,EAAsC,KAAK,MAA3C;AACH;AACJ;AAzF8B,CAAnC","file":"tap-compiled.js","sourcesContent":["/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n"]}